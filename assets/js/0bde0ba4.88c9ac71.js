"use strict";(self.webpackChunkcluster_factory_ce_docs=self.webpackChunkcluster_factory_ce_docs||[]).push([[4114],{5949:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=n(2676),r=n(2494);const o={},i="Storage Architecture",a={id:"guides/storage/storage-architecture",title:"Storage Architecture",description:"Rook Components on Kubernetes",source:"@site/docs/guides/90-storage/02-storage-architecture.md",sourceDirName:"guides/90-storage",slug:"/guides/storage/storage-architecture",permalink:"/docs/guides/storage/storage-architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/deepsquare-io/ClusterFactory/tree/main/web/docs/guides/90-storage/02-storage-architecture.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/guides/storage/overview"},next:{title:"Deploying the Rook Operator",permalink:"/docs/guides/storage/deploying-rook"}},c={},l=[];function d(e){const t={a:"a",h1:"h1",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"storage-architecture",children:"Storage Architecture"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Rook Components on Kubernetes",src:n(2628).Z+"",width:"1563",height:"1534"})}),"\n",(0,s.jsxs)(t.p,{children:["You can read more ",(0,s.jsx)(t.a,{href:"https://rook.io/docs/rook/latest/Getting-Started/storage-architecture/#shared-filesystem",children:"here"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Rook uses a distributed and modular storage architecture to provide robust storage solutions within Kubernetes:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Ceph OSD (Object Storage Daemon)"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Ceph OSD is a critical component in Rook's architecture. It manages the storage devices or partitions attached to each worker node in the cluster."}),"\n",(0,s.jsx)(t.li,{children:"OSDs are responsible for data storage, replication, recovery, and balancing within the Ceph storage cluster."}),"\n",(0,s.jsx)(t.li,{children:"Rook leverages Ceph OSDs to provide scalable and distributed storage resources to applications running in the Kubernetes cluster."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Ceph MON (Monitor)"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Ceph MON is responsible for maintaining the overall health and status of the Ceph storage cluster."}),"\n",(0,s.jsx)(t.li,{children:"MONs store the cluster's metadata, monitor cluster membership changes, and participate in leader election."}),"\n",(0,s.jsx)(t.li,{children:"Rook utilizes Ceph MONs to provide monitoring, management, and coordination for the Ceph storage cluster."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Ceph MGR (Manager)"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Ceph MGR acts as the central management and monitoring daemon within the Ceph storage cluster."}),"\n",(0,s.jsx)(t.li,{children:"MGRs handle cluster-wide tasks, performance monitoring, and provide a RESTful API endpoint for external interactions."}),"\n",(0,s.jsx)(t.li,{children:"Rook utilizes Ceph MGRs to facilitate management, monitoring, and control plane operations for the storage cluster."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Ceph MDS (Metadata Server)"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Ceph MDS is responsible for handling metadata operations in a Ceph file system (CephFS)."}),"\n",(0,s.jsx)(t.li,{children:"MDS servers maintain file system metadata, handle file directory operations, and ensure data consistency."}),"\n",(0,s.jsx)(t.li,{children:"Rook utilizes Ceph MDS to enable the deployment of scalable and distributed file systems within the Kubernetes cluster, offering features such as POSIX semantics and dynamic provisioning of file storage."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"CSI (Container Storage Interface)"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Rook integrates with the Kubernetes CSI framework to provide storage orchestration and dynamic provisioning for persistent volumes."}),"\n",(0,s.jsx)(t.li,{children:"The Rook CSI driver allows Kubernetes workloads to consume storage resources provisioned by Rook."}),"\n",(0,s.jsx)(t.li,{children:"It enables seamless integration with various storage backends, allowing Rook to support different storage technologies, including Ceph, EdgeFS, NFS, and more."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Rook Operator"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Rook Operator is a Kubernetes operator responsible for managing the lifecycle of Rook storage components."}),"\n",(0,s.jsx)(t.li,{children:"It handles the deployment, scaling, upgrading, and monitoring of the Rook storage cluster."}),"\n",(0,s.jsx)(t.li,{children:"The Rook Operator ensures that the desired state of the storage cluster is maintained and handles automated tasks, such as creating OSDs and managing Ceph configuration."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},2628:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/Rook-High-Level-Architecture-dfbe7c84d033828f47578f7dd76d76f3.png"},2494:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>i});var s=n(5271);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);